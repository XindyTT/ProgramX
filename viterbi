p=[1 2;3 4;1 2;3 4];%转换到该状态的第1,2个前状态分别对应的状态值
c=[0 0 0,0 0 1;0 1 1,0 1 0;1 1 1,1 1 0;1 0 0,1 0 1];%第一、二种前状态转换后输出的码字
C=[0 0 0;1 1 1;0 1 1;0 0 1;0 0 0;0 0 0;0 0 1;0 1 0;1 1 0;1 0 1];%发送的码字序列
R=[1 1 0;1 1 1;0 1 1;0 0 1;0 0 0;0 0 0;0 0 1;0 1 0;1 1 0;1 0 1];%接受的码字系列

%计算第l时刻接受码Rl相对于各码字的相似度——分支度量BM
%创建一个三维矩阵，l——x表示第l个时刻，i——z表示对第几个状态的影响，j——y表示前一个状态的个数
for l=1:10
    for j=1:2
        for i=1:4
            BM(l,j,i)=length(find(xor(R(l,:),c(i,((3*j-2):3*j)))==1));
        end 
    end
end
dlmwrite('Result.text',BM(:,:,1)); 
dlmwrite('ResultBM.text',BM);   

%计算第l时刻到达状态i的最大似然路径的相似度——路径度量PM
PM(1,1)=0; %此时表示初始状态
PM(2,1)=inf;
PM(3,1)=inf;
PM(4,1)=inf;
for j=2:11      %表示第j-1个时刻
    for i=1:4   %i表示要转换到第i种状态 
        PM1=PM(p(i,1),(j-1))+BM((j-1),1,i);
        PM2=PM(p(i,2),(j-1))+BM((j-1),2,i);
        PM(i,j)=min(PM1,PM2);
        if PM(i,j)==PM1               %记录当前时刻的状态是由上个时刻的哪个状态决定的
            statenum(i,(j-1))=p(i,1); %i表示转换前的状态的序号，范围1~4，j表示当前时刻
            ordernum(i,(j-1))=1;      %表示对当前状态有影响的是第1or第2种情况
        else
            statenum(i,(j-1))=p(i,2);
            ordernum(i,(j-1))=2;
        end
    end 
end
dlmwrite('ResultPM.text',PM);  

%显示初始时刻的码字序列
%定义一个三维矩阵，i——x表示转换后的码字状态，n——y表示码字的个数，j——z表示当前的时刻
%第一个时刻的所有状态转换对应的输出，长度为4
S(:,(1:9),1)=[0 0 0,0 0 0,0 0 0;  %此时的1代表的是第一个时刻
   0 0 0,0 0 0,0 0 0;
   0 0 0,0 0 0,0 0 0;
   0 0 0,0 0 0,0 0 0;]
for i=1:4
    S(i,(10:12),1)=c(i,(3*ordernum(i,j-1)-2:3*ordernum(i,j-1)));   
end

for j=2:11
    %第一步，将转移前的状态后3个码字移动到转移后的状态输出,并输出第一串译码
    for i=1:4
        S(i,(1:9),j)=S(statenum(i,(j-1)),(4:12),j-1);
    end
    %此时statenum中任何一行对应的状态的前一组输出码都是当前的输出译码
        Decode(j-1,:)=S(statenum(1,(j-1)),(1:3),j-1);
    %第二步，将新生成的码字加入到状态输出中
    for i=1:4
        S(i,(10:12),j)=c(i,(3*ordernum(i,j-1)-2:3*ordernum(i,j-1))); 
    end
end
dlmwrite('Decode.txt',Decode);
